import { documentToReactComponents } from '@contentful/rich-text-react-renderer'
import { BLOCKS } from '@contentful/rich-text-types'
import { ContentfulClientApi, createClient } from 'contentful'
import React from 'react'
import Image from 'next/image'

import config from '@app/src/config'
import { abs_url } from '@app/src/primitives/legacy/Link/Links'

export enum CmsEntryType {
  NewsArticle = 'newsArticle',
  DevLogArticle = 'devlogArticle',
  Page = 'page',
}

export const CmsCanonicalBasePath = {
  [CmsEntryType.Page]: '/',
  [CmsEntryType.NewsArticle]: '/news/',
  [CmsEntryType.DevLogArticle]: '/devlog/',
  fromString: function (s: CmsEntryType | string): string {
    return this[s as CmsEntryType]
  },
}

export interface CmsImage {
  url: string
  alt: string
  width: number | string
  height: number | string
}

export interface CmsEntry {
  id: string
  type: CmsEntryType
  canonicalUrl: string
  publishDate: string
  title: string
  slug: string
  content: object
  summary: object
  bannerImage: CmsImage | null
  metaTitle: string
  metaDescription: string
  robots: string
  enableComments: boolean
  enableSharing: boolean
  category: string
  videoUrl: string | null
  tags: string[]
  isAutogenerated?: boolean | undefined
}

const MissingContentfulAccessTokenError = new Error('CONTENTFUL_ACCESS_TOKEN env var is not set')
const MissingContentfulPreviewTokenError = new Error(
  'CONTENTFUL_PREVIEW_ACCESS_TOKEN env var is not set'
)

const createContentfulClient = (isPreview: boolean): ContentfulClientApi => {
  if (!process.env.CONTENTFUL_ACCESS_TOKEN) {
    throw MissingContentfulAccessTokenError
  }

  if (!process.env.CONTENTFUL_PREVIEW_ACCESS_TOKEN) {
    throw MissingContentfulPreviewTokenError
  }

  return createClient({
    space: config.services.contentful.spaceId,
    environment: config.services.contentful.environment,
    host: isPreview ? 'preview.contentful.com' : 'cdn.contentful.com',
    accessToken: isPreview
      ? process.env.CONTENTFUL_PREVIEW_ACCESS_TOKEN
      : process.env.CONTENTFUL_ACCESS_TOKEN,
  })
}

export async function getStaticPathsForType(
  type: CmsEntryType,
  slugParam: string,
  isPreview: boolean = false
) {
  const contentfulClient = createContentfulClient(isPreview)

  const response = await contentfulClient.getEntries({
    content_type: type,
  })

  return response.items
    .filter((item: any) => {
      // keep if is undefined or true
      return item.fields.isAutoGenerated !== false
    })
    .map((item: any) => ({
      params: {
        [slugParam]: item.fields.slug,
      },
    }))
}

export async function getCmsEntry(
  type: CmsEntryType,
  slug: string,
  canonicalBasePath: string,
  isPreview: boolean = false
): Promise<CmsEntry | null> {
  const contentfulClient = createContentfulClient(isPreview)

  const { items } = await contentfulClient.getEntries({
    content_type: type,
    'fields.slug': slug,
  })

  if (items.length === 0) {
    return null
  }

  return contentfulDocumentToEntry(type, items[0], canonicalBasePath)
}

export async function getCmsEntries(
  type: CmsEntryType,
  canonicalBasePath: string,
  orderBy: string = '-sys.createdAt',
  limit: number = 10,
  isPreview: boolean = false
): Promise<Array<CmsEntry>> {
  const contentfulClient = createContentfulClient(isPreview)

  const { items } = await contentfulClient.getEntries({
    content_type: type,
    order: orderBy,
    limit: limit, // TODO implement pagination
  })

  if (items.length === 0) {
    return []
  }

  return items.map((item: any) => contentfulDocumentToEntry(type, item, canonicalBasePath))
}

export async function getStaticPropsForEntry(
  type: CmsEntryType,
  slug: string,
  canonicalBasePath: string = '/',
  revalidateAfter: number = 0,
  isPreview: boolean = false
) {
  const entry = await getCmsEntry(type, slug, canonicalBasePath, isPreview)

  if (!entry) {
    return {
      redirect: {
        destination: '/404',
        permanent: false,
      },
    }
  }

  return {
    props: {
      entry: entry,
    },
    revalidate: revalidateAfter, // 120 min
  }
}

// Content transformations:

export function transformRichContent(document: any): React.ReactNode {
  return documentToReactComponents(document, {
    renderNode: {
      [BLOCKS.EMBEDDED_ASSET]: (node: any) => {
        // render the EMBEDDED_ASSET as you need
        const fields = node.data.target.fields

        if (!fields || !fields.file || !fields.file.url) {
          return null
        }

        return (
          <Image
            className="responsive-img"
            src={`https:${fields.file.url}`}
            height={fields.file.details.image.height}
            width={fields.file.details.image.width}
            alt={fields.title || fields.description}
          />
        )
      },
    },
  }) as React.ReactNode
}

const contentfulDocumentToEntry = (
  type: CmsEntryType,
  doc: any,
  canonicalBasePath: string
): CmsEntry => {
  const { fields, sys } = doc

  const bannerImage = fields.bannerImage

  return {
    id: sys.id,
    type: type,
    canonicalUrl: abs_url(canonicalBasePath + fields.slug),
    publishDate: sys.createdAt,
    title: fields.title || null,
    slug: fields.slug || null,
    content: fields.content || null,
    summary: fields.summary || null,
    robots: fields.robots || 'index,follow',
    bannerImage: bannerImage
      ? {
          url: 'https:' + bannerImage.fields.file.url,
          alt: bannerImage.fields.title || bannerImage.fields.description || fields.title,
          width: bannerImage.fields.file.details.image.width,
          height: bannerImage.fields.file.details.image.height,
        }
      : null,
    metaTitle: fields.metaTitle || null,
    metaDescription: fields.metaDescription || null,
    category: fields.category || null,
    videoUrl: fields.videoUrl || null,
    tags: fields.tags || [],
    enableComments: fields.enableComments || false,
    enableSharing: fields.enableSharing || false,
  }
}
